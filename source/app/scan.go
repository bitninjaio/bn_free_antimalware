package app

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

var scannedFiles int64
var malwaresFound int64 = 0
var infectedFiles int64 = 0
var startTime time.Time

const API_URL = "https://free.bitninja.io"

var apiUrl string

var cacheData = map[string]string{}

type FileData struct {
	Hash string `json:"hash"`
	Size int64  `json:"size"`
}

type FileBatchData struct {
	Files []FileData `json:"files"`
}

type ScanResult struct {
	Result struct {
		Files []FileResult `json:"files"`
	} `json:"result"`
}

type FileResult struct {
	AnalysisResult string        `json:"analysisResult"`
	Hash           string        `json:"hash"`
	SigData        SignatureData `json:"signatureData"`
}

type SignatureData struct {
	Name      string `json:"name"`
	Id        string `json:"_id"`
	Signature string `json:"signature"`
	Type      string `json:"type"`
	Level     string `json:"level"`
	State     string `json:"state"`
}

func Scan(sourceDir string) {

	defer func() {
		if err := recover(); err != nil {
			klog.Errorf("Error: %v", err)
		}
		endTime := time.Now()
		elapsedTime := endTime.Sub(startTime)
		minutes := int(elapsedTime.Minutes())
		seconds := int(elapsedTime.Seconds()) - (minutes * 60)
		klog.Infof("Scanned files: %d", scannedFiles)
		klog.Infof("Malwares found: %d", malwaresFound)
		klog.Infof("Infected files: %d", infectedFiles)
		klog.Infof("Scanning time: %d minute %d seconds\n", minutes, seconds)
	}()

	apiURL := os.Getenv("API_URL")
	if apiURL == "" {
		apiURL = API_URL
	}

	apiUrl = apiURL + "/malware-scan"

	_, err := os.Stat(sourceDir)
	if os.IsNotExist(err) {
		klog.Errorf("Directory does not exist [%s]", sourceDir)
		return
	} else if err != nil {
		klog.Errorf("Error: %v", err)
		return
	}

	if runtime.GOOS == "windows" {
		if sourceDir == ".\\" || strings.HasPrefix(sourceDir, ".\\") {
			currentDir, _ := os.Getwd()
			sourceDir = filepath.Join(currentDir, strings.TrimPrefix(sourceDir, ".\\"))
		}
	} else {
		if sourceDir == "./" || strings.HasPrefix(sourceDir, "./") {
			currentDir, _ := os.Getwd()
			sourceDir = filepath.Join(currentDir, strings.TrimPrefix(sourceDir, "./"))
		}
	}

	startTime = time.Now()
	klog.Infof("Scanning path: %s", sourceDir)
	err = walkDirectory(sourceDir)
	if err != nil {
		panic(err)
	}
}

func walkDirectory(sourceDir string) error {
	data := FileBatchData{}
	batchSize := 100
	err := filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}

		if info.Mode()&os.ModeSymlink != 0 {
			return nil
		}
		hashString, err1 := calculateMd5(path)
		if err1 != nil {
			klog.Errorf("Error: %v", err)
			return nil
		}

		if info.Size() == 0 {
			klog.Errorf("File size is 0 [%s]", path)
			return nil
		}

		fileData := FileData{
			Hash: strings.ToLower(hashString),
			Size: info.Size(),
		}

		cacheData[fileData.Hash] = path
		data.Files = append(data.Files, fileData)
		if len(data.Files) >= batchSize {
			scannedFiles += int64(len(data.Files))
			err := sendBatch(data, cacheData)
			if err != nil {
				return err
			}

			data = FileBatchData{}
			cacheData = make(map[string]string)
		}
		return nil
	})

	if len(data.Files) > 0 {
		scannedFiles += int64(len(data.Files))
		err := sendBatch(data, cacheData)
		if err != nil {
			return err
		}
	}

	return err
}

func sendBatch(batchData FileBatchData, cacheData map[string]string) error {
	jsonData, err := json.Marshal(batchData)
	if err != nil {
		return fmt.Errorf("marshal error (%v)", err)
	}

	resp, err := http.Post(apiUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("API communication error (%v)", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		if resp.StatusCode == http.StatusTooManyRequests {
			return fmt.Errorf("daily limit reached")
		}
		return fmt.Errorf("unexpected status code: %d %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	var scanResult ScanResult
	if err := json.NewDecoder(resp.Body).Decode(&scanResult); err != nil {
		klog.Errorf("error decoding response:", err)
		return err
	}
	for _, file := range scanResult.Result.Files {
		switch file.AnalysisResult {
		case "malware":
			malwaresFound++
			//klog.Infof("Path: %s, Hash: %s, Analysis Result: %s\n", cacheData[file.Hash], file.Hash, file.AnalysisResult)
		case "injected":
			infectedFiles++
			//klog.Infof("Path: %s, Hash: %s, Analysis Result: %s\n", cacheData[file.Hash], file.Hash, file.AnalysisResult)
		}
	}

	return nil
}

func calculateMd5(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	hashInBytes := hash.Sum(nil)
	hashString := hex.EncodeToString(hashInBytes)

	return hashString, nil
}
